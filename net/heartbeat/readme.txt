1. 为什么需要心跳机制
采用TCP连接的C/S模式软件，连接的双方在连接空闲状态时，如果任意一方意外崩溃、当机、网线断开或路由器故障，另一方无法得知TCP连接已经失效.
除非继续在此连接上发送数据导致错误返回。很多时候，这不是我们需要的。我们希望服务器端和客户端都能及时有效地检测到连接失效，然后优雅地完成一些清理工作并把错误报告给用户。

2. 如何实现
一种是由TCP协议层实现的KeepAlive，另一种是由应用层自己实现的心跳包。

在TCP的机制里面，本身是存在有心跳包的机制的，也就是TCP的选项：SO_KEEPALIVE。系统默认是设置的2小时的心跳频率。但是它检查不到机器断电、网线拔出、防火墙这些断线。而且逻辑层处理断线可能也不是那么好处理。一般，如果只是用于保活还是可以的。

心跳包一般来说都是在逻辑层发送空的echo包来实现的。下一个定时器，在一定时间间隔下发送一个空包给客户端，然后客户端反馈一个同样的空包回来，服务器如果在一定时间内收不到客户端发送过来的反馈包，那就只有认定说掉线了。 
在获知了断线之后，服务器逻辑可能需要做一些事情，比如断线后的数据清理呀，重新连接呀……当然，这个自然是要由逻辑层根据需求去做了。
由应用程序自己发送心跳包来检测连接是否正常，大致的方法是：  
服务器在一个Timer事件中定时向客户端发送一个短小精悍的数据包，然后启动一个低级别的线程，在该线程中不断检测客户端的回应。如果在一定时间内没有收到客户端的回应，即认为客户端已经掉线；
同样，如果客户端在一定时间内没 有收到服务器的心跳包，则认为连接不可用。
对于KeepAlive不论是服务端还是客户端，一方开启KeepAlive功能后，就会自动在规定时间内向对方发送心跳包， 而另一方在收到心跳包后就会自动回复，以告诉对方我仍然在线。 　 
TCP协议层默认并不开启KeepAlive功能.默认的KeepAlive超时需要7,200,000MilliSeconds，即2小时，探测次数为5次。对于很多服务端应用程序来说，2小时的空闲时间太长。因此，我们需要手工开启KeepAlive功能并设置合理的KeepAlive参数。

TCP Keepalive不是TCP规范的一部分，有三点需要注意：
在短暂的故障期间，它们可能引起一个良好连接（good connection）被释放（dropped）
它们消费了不必要的宽带
在以数据包计费的互联网消费（额外）花费金钱

3. 心跳和OOB(带外数据)
TCP是一个流式协议，tcp通带中的数据有序地传递，例如从客户端向服务器传递。此时客户端发生了一个非常重要的事情，需要迅速通知服务端，就需要使用tcp提供了的“带外数据”机制。
TCP报文头部中，有一个URG位标示TCP连接进入紧急状态，还有一个紧急指针，指向带外数据（只能有1个字节）在数据流中位置的后一个字节。
需要注意的是，紧急数据在发送和接受时没有特权，紧急数据时插入到普通的数据中进行流式发送的。收到紧急数据之后，就可以单独进行处理，不必在缓冲区中排队，这个应该才是'高优先级'的含义所在。
在TCP层面（非应用层），发送端缓冲区中，只有先把紧急数据之前的普通数据发送后才能发送紧急数据（但是可以先设置URG标识进入紧急状态）。所以接受端可能会连续接受到几个tcp包，他们的包头部URG被设置，并且紧急指针都指向同一个位置
同时，在接收端只有接收到紧急数据之前的正常数据流之后，才能接受这个字节的带外数据。而且仅接收到的第一个URG（相同紧急指针）的数据包时，才会通过SIGURG通知应用程序进入紧急状态（做好接受准备）
另外，应用程序也可以通过select函数，在exception参数设置要监听的套接字的紧急情况，从而实现紧急数据的主动监听。
著名的telnet和FTP等程序， 就是应用带外数据的典范。 比如， ftp在传输文件的时候， 客户端需要立即通知服务端停止， 此时便可以用带外数据。

心跳数据可以使用OOB机制进行发送。